AC_REVISION("$Id: configure.in,v 1.19 1998/03/02 15:40:38 grubba Exp $")
AC_INIT(cgi.c)
AC_CONFIG_HEADER(config.h)

AC_PROG_CC
AC_SET_MAKE

AC_C_INLINE

AC_CHECK_LIB(bind, __inet_ntoa)
AC_CHECK_LIB(socket, socket)
AC_CHECK_LIB(nsl, main)
AC_CHECK_LIB(resolv, gethostbyname)

AC_DEFINE(POSIX_SOURCE)

AC_HEADER_DIRENT
AC_HEADER_STDC

AC_CHECK_HEADERS(unistd.h stdlib.h stropts.h poll.h malloc.h arpa/inet.h \
		 linux/mman.h sys/mman.h sys/lock.h sys/resource.h \
		 sys/wait.h sys/param.h signal.h)

AC_MSG_CHECKING(existance of h_errno)
AC_CACHE_VAL(pike_cv_h_errno, [
  AC_TRY_LINK([
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#ifdef HAVE_ARPA_INET_H
#include <arpa/inet.h>
#endif /* HAVE_ARPA_INET_H */
#include <netdb.h>
  ],[
int main(int argc, char **argv)
{
  return(h_errno == TRY_AGAIN);
}
  ], [ pike_cv_h_errno=yes ], [ pike_cv_h_errno=no ])
])
if test x$pike_cv_h_errno = xyes; then
  AC_DEFINE(HAVE_H_ERRNO)
fi
AC_MSG_RESULT($pike_cv_h_errno)

AC_MSG_CHECKING(if signal handlers reset automatically)
AC_CACHE_VAL(lpc_cv_sys_signal_oneshot,
[
AC_TRY_RUN([
#include <signal.h>
char sigrun=0;
RETSIGTYPE func(int sig) { sigrun=1; }

int main()
{
#define sig SIGSEGV

#ifdef HAVE_SIGACTION
  {
    struct sigaction action;
    action.sa_handler= func;
    sigfillset(&action.sa_mask);
#ifdef SA_INTERRUPT
    action.sa_flags=SA_INTERRUPT;
#endif
    sigaction(sig,&action,0);
  }
#else
#ifdef HAVE_SIGVEC
  {
    struct sigvec action;
    action.sv_handler= func;
    action.sv_mask=-1;
#ifdef SV_INTERRUPT
    action.sv_flags=SV_INTERRUPT;
#endif
    sigvec(sig,&action,0);
  }
#else
  signal(sig, func);
#endif
#endif

  kill(getpid(), sig);
  while(!sigrun) sleep(1);
  sigrun=0;
  kill(getpid(), sig);
  while(!sigrun) sleep(1);
  sigrun=0;
  exit(0);
}
],lpc_cv_sys_signal_oneshot=no,lpc_cv_sys_signal_oneshot=yes)])

if test "$lpc_cv_sys_signal_oneshot" = yes; then
  AC_MSG_RESULT(yes)
  AC_DEFINE(SIGNAL_ONESHOT)
else
  AC_MSG_RESULT(no)
fi

AC_HAVE_FUNCS(memmove setrlimit pipe socketpair poll shutdown bcopy memcpy realloc mlockall wait3 wait4 waitpid plock memset nice seteuid setresuid)

AC_C_CONST
AC_TYPE_SIZE_T
AC_TYPE_SIGNAL

AC_PATH_PROG(uname_prog,uname,no)

AC_MSG_CHECKING(Data shuffler)

AC_CACHE_VAL(lpc_cv_shuffle, [
  lpc_cv_shuffle="none"
  if test "$uname_prog" != "no"; then
    if test "`uname`" = "SunOS"; then
      case "`uname -m`" in
        sun4*)
	  case "`uname -r`" in
	    5.[45]*) lpc_cv_shuffle="shuffle" ;;
	  esac
        ;;
      esac
    fi
  fi
])

AC_MSG_RESULT($lpc_cv_shuffle)

shuffle=$lpc_cv_shuffle
AC_SUBST(shuffle)

#
####### From Pike 0.6
#

AC_MSG_CHECKING(available file descriptors)
AC_CACHE_VAL(pike_cv_max_open_fd,
[
AC_TRY_RUN([
#include <stdio.h>
#ifdef HAVE_SYS_TIME_H
#include <sys/time.h>
#endif
#ifdef HAVE_SYS_RESOURCE_H
#include <sys/resource.h>
#endif

#ifndef MAX_FD
#define MAX_FD 256
#endif

int main()
{
  FILE *f;
  long limit;

#if !defined(RLIMIT_NOFILE) && defined(RLIMIT_OFILE)
#define RLIMIT_NOFILE RLIMIT_OFILE
#endif

#if defined(HAVE_SETRLIMIT) && defined(RLIMIT_NOFILE)
  struct rlimit lim;

  if(getrlimit(RLIMIT_NOFILE,&lim))
  {
    limit = MAX_FD;
  }else{
    if(lim.rlim_max == RLIM_INFINITY)
    {
      limit=16384; /* noone needs more */
    }else{
      limit=lim.rlim_max;
      if(limit > 16384) limit=16384;
    }
  }
#else
  limit = MAX_FD;
#endif

  f=fopen("conftest.out.2","w");
  fprintf(f,"%ld\n",(long)limit);
  fclose(f);

  return 0;
}
],
pike_cv_max_open_fd=`cat conftest.out.2`
,
pike_cv_max_open_fd=256
,
pike_cv_max_open_fd=256
)])
AC_MSG_RESULT($pike_cv_max_open_fd)
AC_DEFINE_UNQUOTED(MAX_OPEN_FILEDESCRIPTORS,$pike_cv_max_open_fd)

#######

AC_SUBST(LIBS)
AC_CONFIG_SUBDIRS(fast_cgi)
AC_OUTPUT(Makefile,echo FOO >stamp-h )

